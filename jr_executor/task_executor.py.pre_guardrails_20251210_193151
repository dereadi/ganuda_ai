#!/usr/bin/env python3
"""
Cherokee IT Jr - Task Executor
Executes SQL, bash, and file operations with safety checks

Enhanced with Triad Consensus:
- SECURITY: Path restrictions, size limits, backups, audit trail
- EFFICIENCY: Smart task routing, escalation triggers
- ARCHITECTURE: Code block extraction, file task structure

UPDATED 2025-12-10: Now uses intent-based constitutional checking (orthogonal approach)

For Seven Generations
"""

import subprocess
import psycopg2
import os
import shutil
from datetime import datetime
from typing import Dict, Any, List

# Import intent classifier for orthogonal constitutional checking
try:
    from intent_classifier import check_action_intent, Intent
    INTENT_CLASSIFIER_AVAILABLE = True
except ImportError:
    INTENT_CLASSIFIER_AVAILABLE = False


class TaskExecutor:
    # Actions that are NEVER allowed (Constitutional Forbidden - from DOF Phase 4)
    FORBIDDEN_PATTERNS = [
        'rm -rf /',
        'DROP DATABASE',
        'TRUNCATE',
        'sudo rm -rf',
        'sacred_fire_keys',
        'constitutional_archive',
        'seven_generation_plans',
        'mkfs',
        'dd if=',
        '> /dev/',
        'chmod 777 /',
        'shutdown',
        'reboot',
        'init 0',
    ]

    # Tables we should never modify directly
    PROTECTED_TABLES = [
        'constitutional_archive',
        'cherokee_council_decisions',
        'legal_llama_consultations',
        'seven_generation_plans',
        'sacred_fire_keys',
        'tribal_governance',
    ]

    # SECURITY: Paths Jr is ALLOWED to write files (Triad Security Consensus)
    ALLOWED_FILE_PATHS = [
        '/ganuda/',
        '/tmp/',
        '/Users/Shared/ganuda/',
    ]

    # SECURITY: Paths Jr must NEVER write to
    FORBIDDEN_FILE_PATHS = [
        '/etc/',
        '/usr/',
        '/bin/',
        '/sbin/',
        '/root/',
        '/home/',
        '/var/log/',
        '/boot/',
        '/sys/',
        '/proc/',
    ]

    # SECURITY: Maximum file size Jr can write (50KB - Triad consensus)
    MAX_FILE_SIZE = 50 * 1024

    # EFFICIENCY: File types Jr should escalate (require Chief approval)
    ESCALATE_FILE_TYPES = [
        '.service',  # systemd services
        '.conf',     # system config
        '.cron',     # cron jobs
        '.sudoers',  # sudo config
    ]

    def __init__(self):
        self.db_config = {
            'host': '192.168.132.222',
            'database': 'triad_federation',
            'user': 'claude',
            'password': 'jawaseatlasers2'
        }

    def execute_steps(self, steps: List[Dict]) -> List[Dict[str, Any]]:
        """Execute a list of steps and return results"""
        results = []
        for step in steps:
            result = self.execute(step)
            results.append(result)
            # Stop on critical failure
            if not result.get('success') and step.get('critical', True):
                break
        return results

    def execute(self, step: Dict) -> Dict[str, Any]:
        """Execute a single step and return result"""
        step_type = step.get('type', 'unknown')

        # Safety check
        if self._is_forbidden(step):
            return {
                'success': False,
                'error': 'Action forbidden by constitutional rules',
                'step': step
            }

        try:
            if step_type == 'sql':
                return self._execute_sql(step)
            elif step_type == 'bash':
                return self._execute_bash(step)
            elif step_type == 'file':
                return self._execute_file(step)
            elif step_type == 'rsync':
                return self._execute_rsync(step)
            else:
                return {'success': False, 'error': f'Unknown step type: {step_type}'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'step': step}

    def _is_forbidden(self, step: Dict) -> bool:
        """Check if step is forbidden using intent-based classification (orthogonal approach)"""

        # Use intent classifier if available (orthogonal approach)
        if INTENT_CLASSIFIER_AVAILABLE:
            return self._intent_based_check(step)

        # Fallback to legacy pattern matching
        return self._legacy_forbidden_check(step)

    def _intent_based_check(self, step: Dict) -> bool:
        """Intent-based constitutional check - checks WHAT you're trying to do, not words used"""
        step_type = step.get('type', 'unknown')
        step_str = str(step)

        # Build context for intent classification
        context = {
            'trust_level': 100,  # Jr default trust
            'chief_authorized': False
        }

        if step_type == 'file':
            args = step.get('args', {})
            operation = args.get('operation', 'read')
            if operation == 'write':
                context['operation'] = 'CREATE_FILE'
            elif operation == 'read':
                context['operation'] = 'READ_FILE'
            elif operation in ['delete', 'remove']:
                context['operation'] = 'DELETE_FILE'
            context['target_path'] = args.get('path', '')

        elif step_type == 'sql':
            cmd = step.get('command', '').strip().upper()
            if cmd.startswith('SELECT'):
                context['operation'] = 'SELECT'
            elif cmd.startswith('INSERT'):
                context['operation'] = 'INSERT'
            elif cmd.startswith('UPDATE'):
                context['operation'] = 'UPDATE'
            elif cmd.startswith('DELETE'):
                context['operation'] = 'DELETE'
            # Extract table name if possible
            for table in self.PROTECTED_TABLES:
                if table.lower() in step_str.lower():
                    context['target_table'] = table
                    break

        elif step_type == 'bash':
            context['operation'] = 'BASH'

        # Check with intent classifier
        allowed, reason, intent = check_action_intent(step_str, context)
        return not allowed

    def _legacy_forbidden_check(self, step: Dict) -> bool:
        """Legacy pattern-matching check - fallback if intent classifier unavailable"""
        step_str = str(step).lower()

        # Check forbidden patterns
        for pattern in self.FORBIDDEN_PATTERNS:
            if pattern.lower() in step_str:
                return True

        # Check protected tables for modification
        if step.get('type') == 'sql':
            cmd = step.get('command', '').upper()
            if any(kw in cmd for kw in ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'ALTER']):
                for table in self.PROTECTED_TABLES:
                    if table.lower() in step_str:
                        return True

        return False

    def _execute_sql(self, step: Dict) -> Dict:
        """Execute SQL command"""
        try:
            conn = psycopg2.connect(**self.db_config)
            cur = conn.cursor()

            command = step.get('command', '')
            cur.execute(command)

            if command.strip().upper().startswith('SELECT'):
                result = cur.fetchall()
                columns = [desc[0] for desc in cur.description] if cur.description else []
            else:
                result = cur.rowcount
                columns = []
                conn.commit()

            cur.close()
            conn.close()

            return {
                'success': True,
                'result': result,
                'columns': columns,
                'type': 'sql'
            }
        except Exception as e:
            return {'success': False, 'error': str(e), 'type': 'sql'}

    def _execute_bash(self, step: Dict) -> Dict:
        """Execute bash command with safety limits"""
        try:
            command = step.get('command', '')
            timeout = step.get('timeout', 300)  # 5 minute default

            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=step.get('cwd', '/tmp')
            )

            return {
                'success': result.returncode == 0,
                'stdout': result.stdout[:10000],  # Limit output size
                'stderr': result.stderr[:2000],
                'returncode': result.returncode,
                'type': 'bash'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Command timed out', 'type': 'bash'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'type': 'bash'}

    def _execute_file(self, step: Dict) -> Dict:
        """Execute file operation (read/write) with Triad security checks"""
        try:
            args = step.get('args', {})
            operation = args.get('operation', 'read')
            path = args.get('path', '')
            content = args.get('content', '')
            backup = args.get('backup', True)

            # SECURITY: Validate path basics
            if not path or '..' in path:
                return {'success': False, 'error': 'Invalid path (empty or contains ..)'}

            # SECURITY: Check allowed paths for write operations
            if operation in ['write', 'append']:
                if not self._is_path_allowed(path):
                    return {
                        'success': False,
                        'error': f'Path not in allowed directories: {path}',
                        'escalate': True
                    }

                # SECURITY: Check forbidden paths
                if self._is_path_forbidden(path):
                    return {
                        'success': False,
                        'error': f'Path in forbidden directory: {path}',
                        'escalate': True
                    }

                # SECURITY: Check file size limit
                if len(content) > self.MAX_FILE_SIZE:
                    return {
                        'success': False,
                        'error': f'Content exceeds max size ({len(content)} > {self.MAX_FILE_SIZE})',
                        'escalate': True
                    }

                # EFFICIENCY: Check if file type needs escalation
                if self._needs_escalation(path):
                    return {
                        'success': False,
                        'error': f'File type requires Chief approval: {path}',
                        'escalate': True
                    }

            if operation == 'read':
                if not os.path.exists(path):
                    return {'success': False, 'error': f'File not found: {path}'}
                with open(path) as f:
                    content = f.read()
                return {'success': True, 'content': content[:50000], 'type': 'file'}

            elif operation == 'write':
                # SECURITY: Backup existing file before overwrite
                backup_path = None
                if backup and os.path.exists(path):
                    backup_path = self._backup_file(path)

                # Ensure directory exists
                dir_path = os.path.dirname(path)
                if dir_path:
                    os.makedirs(dir_path, exist_ok=True)

                with open(path, 'w') as f:
                    f.write(content)

                # SECURITY: Audit log to thermal memory
                self._audit_file_operation('write', path, len(content), backup_path)

                return {
                    'success': True,
                    'written': len(content),
                    'path': path,
                    'backup': backup_path,
                    'type': 'file'
                }

            elif operation == 'append':
                with open(path, 'a') as f:
                    f.write(content)
                self._audit_file_operation('append', path, len(content), None)
                return {'success': True, 'appended': len(content), 'type': 'file'}

            else:
                return {'success': False, 'error': f'Unknown file operation: {operation}'}

        except Exception as e:
            return {'success': False, 'error': str(e), 'type': 'file'}

    def _is_path_allowed(self, path: str) -> bool:
        """SECURITY: Check if path is in allowed directories"""
        return any(path.startswith(allowed) for allowed in self.ALLOWED_FILE_PATHS)

    def _is_path_forbidden(self, path: str) -> bool:
        """SECURITY: Check if path is in forbidden directories"""
        return any(path.startswith(forbidden) for forbidden in self.FORBIDDEN_FILE_PATHS)

    def _needs_escalation(self, path: str) -> bool:
        """EFFICIENCY: Check if file type requires Chief approval"""
        return any(path.endswith(ext) for ext in self.ESCALATE_FILE_TYPES)

    def _backup_file(self, path: str) -> str:
        """SECURITY: Create backup before overwriting"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_path = f"{path}.backup_{timestamp}"
        shutil.copy2(path, backup_path)
        return backup_path

    def _audit_file_operation(self, operation: str, path: str, size: int, backup_path: str):
        """SECURITY: Log file operation to thermal memory for audit trail"""
        try:
            conn = psycopg2.connect(**self.db_config)
            cur = conn.cursor()

            audit_content = f"FILE_AUDIT: {operation.upper()} {path} ({size} bytes)"
            if backup_path:
                audit_content += f" [backup: {backup_path}]"

            cur.execute("""
                INSERT INTO triad_shared_memories
                (content, temperature, source_triad, tags, access_level)
                VALUES (%s, %s, %s, %s, %s)
            """, (
                audit_content,
                40.0,  # Low temperature - operational log
                'it_triad_jr',
                ['audit', 'file_operation', operation],
                'federation'
            ))

            conn.commit()
            cur.close()
            conn.close()
        except Exception:
            pass  # Don't fail the operation if audit fails

    def _execute_rsync(self, step: Dict) -> Dict:
        """Execute rsync command"""
        try:
            args = step.get('args', {})
            source = args.get('source', '')
            dest = args.get('dest', '')
            options = args.get('options', '-avz')

            if not source or not dest:
                return {'success': False, 'error': 'rsync requires source and dest'}

            command = f"rsync {options} {source} {dest}"

            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600  # 10 minute timeout for rsync
            )

            return {
                'success': result.returncode == 0,
                'stdout': result.stdout[:5000],
                'stderr': result.stderr[:2000],
                'type': 'rsync'
            }
        except Exception as e:
            return {'success': False, 'error': str(e), 'type': 'rsync'}
